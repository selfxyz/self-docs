# SelfBackendVerifier

The `SelfBackendVerifier` class is designed to facilitate the verification of user credentials and disclosures in applications using the Self system. It supports various modes of operation, allowing for both onchain and offchain proof verification. The class provides methods to configure verification parameters such as minimum age, nationality, and OFAC checks, and to generate intents for user interactions.



### Overview

The SelfBackendVerifier:

* Verifies zero-knowledge proofs generated by the Self mobile app
* Validates proof integrity against on-chain merkle roots
* Enforces verification requirements through the IConfigStorage interface
* Supports both real passports (mainnet) and mock passports (testnet)
* Handles multiple attestation types (passports, EU ID cards)

### Constructor

```typescript
new SelfBackendVerifier(
  scope: string,
  endpoint: string,
  mockPassport: boolean,
  allowedIds: Map<AttestationId, boolean>,
  configStorage: IConfigStorage,
  userIdentifierType: UserIdType
)
```

#### Parameters

| Parameter          | Type                          | Description                                                                                                |
| ------------------ | ----------------------------- | ---------------------------------------------------------------------------------------------------------- |
| scope              | `string`                      | Your application's unique identifier. Used to ensure proofs are generated for your app. Max 31 characters. |
| endpoint           | `string`                      | Your backend verification endpoint URL. Must be publicly accessible.                                       |
| mockPassport       | `boolean`                     | `false` for real passports (mainnet), `true` for testing (testnet)                                         |
| allowedIds         | `Map<AttestationId, boolean>` | Map of allowed document types. Key: attestation ID, Value: allowed status                                  |
| configStorage      | `IConfigStorage`              | Implementation of configuration storage interface                                                          |
| userIdentifierType | `UserIdType`                  | Type of user identifier: `'uuid'` or `'hex'` (for blockchain addresses)                                    |

#### Example

```typescript
import { 
  SelfBackendVerifier, 
  IConfigStorage, 
  DefaultConfigStore,
  AllIds,
  AttestationId
} from '@selfxyz/core';

// Option 1: Accept all supported document types
const verifier = new SelfBackendVerifier(
  'my-app-scope',
  'https://api.myapp.com/verify',
  false,  // Use real passports
  AllIds, // Accept all supported attestation types
  new DefaultConfigStore({ 
    olderThan: 18,
    excludedCountries: ['IRN', 'PRK'],
    ofac: true 
  }),
  'uuid'  // User identifier type
);

// Option 2: Accept only passports
const allowedIds = new Map<AttestationId, boolean>();
allowedIds.set(1, true); // Only passports

const verifier = new SelfBackendVerifier(
  'my-app-scope',
  'https://api.myapp.com/verify',
  false,
  allowedIds,
  configStorage,
  'hex'  // For blockchain addresses
);
```

### Methods

#### verify

Verifies a zero-knowledge proof against configured requirements.

```typescript
async verify(
  attestationId: AttestationId,
  proof: VcAndDiscloseProof,
  pubSignals: BigNumberish[],
  userContextData: string
): Promise<VerificationResult>
```

**Parameters**

| Parameter       | Type                 | Description                                                       |
| --------------- | -------------------- | ----------------------------------------------------------------- |
| attestationId   | `AttestationId`      | Document type identifier (1 = passport, 2 = EU ID card)           |
| proof           | `VcAndDiscloseProof` | Zero-knowledge proof object containing `a`, `b`, `c` arrays       |
| pubSignals      | `BigNumberish[]`     | Array of public signals from the proof                            |
| userContextData | `string`             | Hex-encoded string containing user context and configuration data |

**Returns**

`Promise<VerificationResult>` with the following structure:

```typescript
{
  attestationId: AttestationId;           // Document type verified
  isValidDetails: {
    isValid: boolean;                     // Overall verification result
    isOlderThanValid: boolean;            // Age verification result
    isOfacValid: boolean;                 // OFAC check result
  };
  forbiddenCountriesList: string[];      // List of excluded countries from proof
  discloseOutput: {                       // Disclosed passport data
    nullifier: string;                    // Unique identifier preventing reuse
    forbiddenCountriesListPacked: string[];
    issuingState: string;                 // Country that issued the document
    name: string;                         // Full name (if disclosed)
    idNumber: string;                     // Document number
    nationality: string;                  // Nationality
    dateOfBirth: string;                  // Date of birth (if disclosed)
    gender: string;                       // Gender
    expiryDate: string;                   // Document expiry date
    olderThan: string;                    // Age verification result
    ofac: boolean[];                      // OFAC check results [passportNo, nameAndDob, nameAndYob]
  };
  userData: {
    userIdentifier: string;               // Extracted user identifier
    userDefinedData: string;              // Additional user data
  };
}
```

**Errors**

The method throws `ConfigMismatchError` when verification requirements don't match:

```typescript
try {
  const result = await verifier.verify(attestationId, proof, pubSignals, userContextData);
} catch (error: any) {
  if (error.name === 'ConfigMismatchError') {
    console.error('Configuration mismatches:', error.issues);
    // error.issues is an array of { type: ConfigMismatch, message: string }
  }
}
```

Possible `ConfigMismatch` types:

* `InvalidId` - Attestation ID not in allowedIds
* `InvalidScope` - Proof generated for different scope
* `InvalidRoot` - Merkle root not found on-chain
* `InvalidForbiddenCountriesList` - Countries don't match configuration
* `InvalidMinimumAge` - Age requirement mismatch
* `InvalidTimestamp` - Proof timestamp out of valid range (±1 day)
* `InvalidOfac` - OFAC check mismatch
* `ConfigNotFound` - Configuration not found in storage

### Types

> **Note**: Some types like `UserIdType` and `ConfigMismatchError` are used internally but not exported from `@selfxyz/core`. Use string literals (`'uuid'` or `'hex'`) directly for user identifier types.

#### AttestationId

Numeric identifier for document types:

* `1` - Electronic passport
* `2` - EU ID card

#### UserIdType

String literal type for user identifier format:

* `'uuid'` - Standard UUID format
* `'hex'` - Hexadecimal format (for blockchain addresses)

#### VcAndDiscloseProof

Zero-knowledge proof structure:

```typescript
{
  a: [BigNumberish, BigNumberish];
  b: [[BigNumberish, BigNumberish], [BigNumberish, BigNumberish]];
  c: [BigNumberish, BigNumberish];
}
```

#### VerificationConfig

Configuration for verification requirements:

```typescript
{
  olderThan?: number;              // Minimum age requirement
  excludedCountries?: string[];    // ISO 3-letter country codes
  ofac?: boolean;                  // Enable OFAC sanctions checking
}
```

### Complete Example

```typescript
import { 
  SelfBackendVerifier,
  IConfigStorage,
  VerificationConfig,
  AttestationId,
  InMemoryConfigStore
} from '@selfxyz/core';
import { BigNumberish } from 'ethers';

// Configure storage with different requirements per action
const configStorage = new InMemoryConfigStore(
  async (userIdentifier: string, data: string) => {
    // Determine config based on user action
    const action = JSON.parse(data).action;
    return action === 'high_value' ? 'strict_config' : 'standard_config';
  }
);

// Set up configurations
await configStorage.setConfig('standard_config', {
  olderThan: 18,
  ofac: false
});

await configStorage.setConfig('strict_config', {
  olderThan: 21,
  excludedCountries: ['IRN', 'PRK', 'CUB'],
  ofac: true
});

// Initialize verifier
const allowedIds = new Map<AttestationId, boolean>();
allowedIds.set(1, true); // Passports
allowedIds.set(2, true); // EU ID cards

const verifier = new SelfBackendVerifier(
  'my-app-scope',
  'https://api.myapp.com/verify',
  false,  // Production mode
  allowedIds,
  configStorage,
  'uuid'  // User identifier type
);

// In your API handler
async function handleVerification(req: Request): Promise<Response> {
  const { attestationId, proof, pubSignals, userContextData } = req.body;
  
  try {
    const result = await verifier.verify(
      attestationId,
      proof,
      pubSignals as BigNumberish[],
      userContextData
    );
    
    if (result.isValidDetails.isValid) {
      // Check specific validations
      if (!result.isValidDetails.isOlderThanValid) {
        return new Response('Age requirement not met', { status: 403 });
      }
      
      if (!result.isValidDetails.isOfacValid) {
        return new Response('OFAC check failed', { status: 403 });
      }
      
      // Verification successful
      return new Response(JSON.stringify({
        verified: true,
        nullifier: result.discloseOutput.nullifier,
        nationality: result.discloseOutput.nationality,
        olderThan: result.discloseOutput.olderThan
      }), { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    return new Response('Verification failed', { status: 400 });
    
  } catch (error: any) {
    if (error.name === 'ConfigMismatchError') {
      // Log specific issues for debugging
      console.error('Config mismatches:', error.issues);
      
      return new Response(JSON.stringify({
        error: 'Configuration mismatch',
        issues: error.issues
      }), { 
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    console.error('Verification error:', error);
    return new Response('Internal server error', { status: 500 });
  }
}
```

### Migration from Previous Versions

If you're migrating from an older version that used methods like `setMinimumAge()`:

#### Old API (No longer supported):

```typescript
// ❌ These methods no longer exist
verifier.setMinimumAge(18);
verifier.excludeCountries('Iran', 'North Korea');
verifier.enableNameAndDobOfacCheck();
```

#### New API:

```typescript
// ✅ Configuration via IConfigStorage
const configStorage = new DefaultConfigStore({
  olderThan: 18,
  excludedCountries: ['IRN', 'PRK'],
  ofac: true
});
```

### Best Practices

1. **Reuse Verifier Instance**: Create the verifier once and reuse it for all verifications
2. **Handle All Error Types**: Always catch and handle `ConfigMismatchError`
3. **Validate Input**: Ensure all parameters are present before calling verify
4. **Use Appropriate Storage**: Implement `IConfigStorage` based on your needs (in-memory, database, etc.)
5. **Monitor Nullifiers**: Store nullifiers to prevent proof reuse if needed
6. **Test with Mock Passports**: Use `mockPassport: true` for development and testing

### Network Information

* **Mainnet** (Real passports): Celo Mainnet - `https://forno.celo.org`
* **Testnet** (Mock passports): Celo Alfajores - `https://alfajores-forno.celo-testnet.org`

The network is automatically selected based on the `mockPassport` parameter.
